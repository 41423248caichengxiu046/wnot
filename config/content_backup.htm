<h1>About</h1>
<p>課程名稱: 計算機程式</p>
<p>示範網站: <a href="https://mde.tw/cp_demo">https://mde.tw/cp_demo</a></p>
<p>示範倉儲: <a href="https://github.com/mdecycu/cp_demo">https://github.com/mdecycu/cp_demo</a> </p>
<p>w14-w18: Python (Flask)，Brython，Peewee (ORM)，SQLite</p>
<p style="padding-left: 30px;">Brython 程式環境: </p>
<p style="padding-left: 60px;"><a href="https://s5.eng.nfu.edu.tw:9499/">https://s5.eng.nfu.edu.tw:9499/</a> (部署到 Linux)</p>
<p style="padding-left: 60px;"><a href="https://github.com/mdecycu/brython_proj">https://github.com/mdecycu/brython_proj</a> (原始碼)</p>
<p style="padding-left: 30px;">英雄榜: </p>
<p style="padding-left: 60px;"><a href="https://s5.eng.nfu.edu.tw:9498/">https://s5.eng.nfu.edu.tw:9498/</a> (部署到 Linux)</p>
<p style="padding-left: 60px;"><a href="https://github.com/mdecycu/cp_final_ex">https://github.com/mdecycu/cp_final_ex</a> (原始碼)</p>
<p>課程評分:</p>
<p style="padding-left: 30px;"><span style="background-color: #ffff00;">學習心得報告 (60%)</span> - MS Teams 線上參與，<span style="background-color: #ccffcc;">6人一組</span>每三週發表學習心得。</p>
<p style="padding-left: 60px;">w3、w7、w10、w14、w17、w18</p>
<p style="padding-left: 60px;">學習心得報告主題:</p>
<p style="padding-left: 60px;">w3: 什麼是 git, GitHub, gist 與 cmsimde? 如何使用這些工具？為什麼要使用這些工具？ (<a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/b4134dc3724f9c6aa1de7534a74f298288de0fa5/round_dot_move.py">動態模擬</a>)</p>
<p style="padding-left: 60px;">w7: Brython 是什麼？如何在瀏覽器配置 Brython 環境？ Brython 能做什麼？ (<a href="https://mde.tw/cp2025/content/Brython.html">Brython</a>, <a href="https://mde.tw/cp2025/content/Robot_ex.html">Examples</a>)</p>
<p style="padding-left: 60px;">w10: 如何在瀏覽器中模擬機器人作動？ (<a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/58fed8bd2f5be98a6456a8dcae512011/raw/4019adba4ee4be19c35982d835bad8e7d83a7b2f/brython_robot4_ex1.py">機器人作動</a>)</p>
<p style="padding-left: 60px;">w14: 在瀏覽器中模擬機器人作動的目的是什麼？ (<a href="/downloads/otto_robot.7z">otto_robot.7z</a>, <a href="https://mde.tw/cad2025/content/Homework.html">Plotter</a>, <a href="/downloads/open_duck_mini.7z">open_duck_mini.7z</a> ,<a href="https://webots.cloud/AcTNYs0">https://webots.cloud/AcTNYs0</a>)</p>
<p style="padding-left: 60px;">w17 (<span style="background-color: #ccffcc;">1b 採 Youtube 影片簡報</span>): 計算機程式課程學到了什麼？</p>
<p style="padding-left: 60px;">w18: 課程總結</p>
<p style="padding-left: 30px;"><span style="background-color: #ffff00;">個人與分組網站維護 (40%)</span> - 每週至少兩次推送與課程進度相關的學習內容與心得。</p>
<p style="padding-left: 60px;">w9 期中自評、w18 期末自評</p><h2>AI</h2>
<p><a href="https://link.springer.com/book/10.1007/978-3-032-09008-9">Let's talk AI</a></p>
<p>In observing the numerous discussions about the rapid advancement of artificial intelligence (AI), it is clear that while there is much sharing of ideas, in fact true collaboration, challenging concepts, and alignment is rare. We still operate in silos. Given the critical, pervasive, and revolutionary nature of AI, it is vital that we move forward carefully, holistically, and collaboratively to ensure that our decisions and progress are deliberate and well-considered.</p>
<p>在觀察有關人工智慧（AI）快速發展的諸多討論時，我們可以明顯看到，雖然有許多思想的交流，但實際上，真正的合作、挑戰性的觀念以及協調仍然很少。我們依然處於各自為政的狀態。鑒於人工智慧的關鍵性、普遍性和革命性質，我們<span style="background-color: #ccffcc;">必須謹慎、全面並協同前進</span>，確保我們的決策和進展是經過深思熟慮且周詳的。</p>
<p>This book presents interdisciplinary dialogues on artificial intelligence, all derived from the same semi-structured interview format. These interviews were conducted with the goal of uncovering opportunities for collaboration, identifying gaps, and exploring the multiple meanings and perceptions attached to commonly used terms in the field of AI.</p>
<p>本書呈現了關於人工智慧的跨學科對話，所有對話皆源自相同的半結構化訪談格式。這些訪談的目的是<span style="background-color: #ccffcc;">揭示合作的機會、識別存在的空白，並探索在人工智慧領域中，對常用術語所附加的多重意涵與不同看法</span>。</p>
<p>Here we explain the definitions used in the interviews. We observed a wide range of opinions. This variance in the views of experts may stem from their focus on different aspects of AI, their interpretations of key terms, or their perspectives on the consequences and mechanisms involved.<br/>To provide clearer insights into these differences, we decided to open the interview chapters with the interpretations each expert has on key terms. The approach is not meant to offer a uniform understanding but it allows readers to interpret the experts’ answers in the light of their intended meanings and definitions.</p>
<p>Here we justify the key terms selected:</p>
<p>在此，我們解釋了訪談中所使用的定義。我們觀察到有著各種不同的觀點。這些<span style="background-color: #ccffcc;">專家的觀點差異可能來自於他們對人工智慧的不同關注重點、對關鍵術語的詮釋，或是他們對相關後果和機制的理解與看法</span>。<br/><br/>為了能更清楚地呈現這些差異，我們決定在每一章的訪談部分開頭，介紹每位專家對關鍵術語的詮釋。這種做法並非旨在提供一個統一的理解，而是讓讀者能夠在專家所表達的意圖與定義下解讀他們的回答。<br/><br/>接下來，我們將對所選擇的關鍵術語進行解釋：</p>
<p>Artificial Intelligence – While everyone is familiar with AI, perceptions of what it entails can vary widely. In scientific research, a clear definition of AI is crucial for overall interpretation. Since there is no universally agreed upon definition, each interviewee was invited to provide their personal interpretation.</p>
<p>人工智慧 – 雖然每個人<span style="background-color: #ccffcc;">對人工智慧</span>（AI）都有所了解，但對其內涵的看法可能差異很大。在科學研究中，對人工智慧的明確定義對於整體解讀至關重要。由於<span style="background-color: #ccffcc;">目前並沒有普遍公認的定義</span>，我們邀請每位受訪者提供他們對人工智慧的個人詮釋。</p>
<p>The biggest differences between AI and other technologies are, in a nutshell:</p>
<p>Power – AI has capabilities that surpass any previous technology, performing complex and diverse tasks that often exceed human capabilities. As AI evolves, it requires less and less deliberate and conscious effort to reach new levels of creativity. This ease of development, combined with AI’s ability to continually surprise us with emerging properties, sets it apart from past innovations.</p>
<p>Versatility – AI’s adaptability across multiple sectors, from healthcare to finance and manufacturing, demonstrates its unprecedented versatility. While there are many dedicated AI systems, there are also increasingly many that bridge domains and tasks, amplifying their impact on society as they reach millions of users. This interconnectedness allows AI to (unconsciously) shape thoughts, actions, and outcomes at scale, further underscoring its powerful impact.</p>
<p>Autonomy – Perhaps most importantly, AI can operate with minimal human oversight, capable of making decisions and performing tasks independently. While we are amazed by its functionality, our understanding of why and how it works remains limited. This opacity, even for leading experts, complicates the relationship between AI and its users.</p>
<p>人工智慧與其他技術的最大區別，簡而言之有以下幾點：</p>
<p>功能 – 人工智慧擁有<span style="background-color: #ccffcc;">超越以往任何技術的能力</span>，能執行複雜且多樣的任務，這些任務往往超越了人類的能力範疇。隨著人工智慧的發展，它所需的有意識和刻意努力越來越少，便能達到新的創造力層次。這種發展的輕鬆性，加上人工智慧不斷以出乎意料的新特性驚訝我們，將其與過去的創新技術區別開來。</p>
<p>多樣性 – 人工智慧在多個領域的適應性，<span style="background-color: #ccffcc;">從醫療到金融，再到製造業，展示了其前所未有的多樣性</span>。雖然有許多專門的人工智慧系統，但也有越來越多的系統跨越領域和任務，隨著它們觸及數百萬用戶，進一步放大了對社會的影響。這種互聯性使得人工智慧能在無意識中（或至少無需直接干預）大規模地影響思想、行為和結果，進一步凸顯了其強大的影響力。</p>
<p>自主性 – 也許最重要的是，<span style="background-color: #ccffcc;">人工智慧能在最小的人類監督下運作，能夠獨立做出決策並執行任務</span>。儘管我們對它的功能感到驚訝，但我們<span style="background-color: #ccffcc;">對它運作的原因和方式仍然了解有限</span>。這種不透明性，即便對於領先的專家來說，也使人工智慧與使用者之間的關係變得複雜。</p><h1>Revealjs</h1>
<p>既存技術:</p>
<p style="padding-left: 30px;"><a href="https://github.com/scrum-1/respysive-slide">https://github.com/scrum-1/respysive-slide</a></p>
<p>專案簡介：非同步分散式 Reveal.js 協同簡報編輯系統</p>
<p>各學員利用 <a href="https://github.com/fbxyz/respysive-slide">https://github.com/fbxyz/respysive-slide</a> 模組，以位於 downloads 目錄的 <a href="/downloads/reveal_file.py">reveal_file.py</a> 建立簡報。(<a href="https://mde.tw/cp_demo/reveal/index.html">簡報結果</a>)</p>
<p>各學員進行協同倉儲內容編輯時，可以先將版本推送至個人倉儲分支，待階段性內容完成後，再設法與主分支或其他測試用分支進行合併。若合併之版本內容有衝突(同位置的新舊版本內容取捨)，則必須設法解決衝突內容後，再進行後續的新增、提交與推送。</p><h1>Python</h1>
<p><a href="https://github.com/mdecycu/python_2025/blob/main/%E7%AC%AC01%E8%AA%B2%EF%BC%9A%E5%88%9D%E8%AD%98Python.md">Python 程式教材</a> (中文)</p>
<p>透過 <a href="https://mde.tw/cp2025/content/Robot_ex.html">https://mde.tw/cp2025/content/Robot_ex.html</a> 學習 Python 程式語法。</p>
<p>Python 基本語法: <a href="https://link.springer.com/chapter/10.1007/978-3-031-90522-3_1">Python essential</a> (英文，只能在校網擷取)</p>
<p>Python 變數宣告原則:</p>
<p>在 Python 中，變數宣告（Variable Declaration）相較於其他語言（如 Java 或 C++）來得簡單，因為 Python 是動態型別語言。以下是 Python 宣告變數的原則與最佳實踐：</p>
<p><span style="background-color: #ffff99;">一、不需明確指定型別</span></p>
<p style="padding-left: 30px;"><span style="background-color: #ccffcc;">Python 是動態型別語言，你不需要指定變數型別</span>，解譯器會根據賦值自動判斷。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">x = 10        # 整數
name = "Amy"  # 字串
pi = 3.14     # 浮點數
</pre>
<p><span style="background-color: #ffff99;">二、變數名稱命名規則</span></p>
<p style="padding-left: 30px;">合法命名：<br/><br/><span style="background-color: #ccffcc;">可以包含字母、數字、底線（_）</span><br/><br/><span style="background-color: #ccffcc;">不能以數字開頭</span><br/><br/><span style="background-color: #ccffcc;">不能使用 Python 保留的關鍵字(35個)</span>:</p>
<p style="padding-left: 60px;">['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', '<span style="background-color: #ffcc99;">def</span>', 'del', 'elif', '<span style="background-color: #ffcc99;">else</span>', 'except', 'finally', '<span style="background-color: #ffcc99;">for</span>', 'from', 'global', '<span style="background-color: #ffcc99;">if</span>', '<span style="background-color: #ffcc99;">import</span>', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']</p>
<p style="padding-left: 30px;">利用 keyword 模組，<a href="https://mde.tw/cp_demo/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/fa7d2a68d1569596f62e5b7739a83119/raw/da44925c2f9694f825c2525edfc80367f327ca5e/print_keywords.py">列出 Python 所保留的關鍵字</a>:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import keyword

# 印出關鍵字清單
print("Python 保留關鍵字有：")
print(keyword.kwlist)

# 印出總數
print("\n關鍵字總數：", len(keyword.kwlist))</pre>
<p><span style="background-color: #ffff99;">三、使用有意義的變數名稱</span></p>
<p style="padding-left: 30px;">例如: grid_width = 10</p>
<p><span style="background-color: #ffff99;">四、遵守 Python 命名慣例（<a href="https://peps.python.org/pep-0008/" style="background-color: #ffff99;">PEP 8</a>）</span></p>
<p style="padding-left: 30px;"><span style="background-color: #ccffcc;">小寫 + 底線 用於變數和函數名稱：total_price</span><br/><br/><span style="background-color: #ccffcc;">全大寫 用於常數：MAX_SIZE</span><br/><br/><span style="background-color: #ccffcc;">大駝峰式（PascalCase） 用於類別名稱：StudentProfile</span></p>
<p><span style="background-color: #ffff99;">五、Python 變數名稱區分大小寫</span></p>
<p style="padding-left: 30px;">length 與 Length 是兩個不同的變數名稱</p>
<p><span style="background-color: #ffff99;">六、變數可重新指派不同型別（動態型別特性）</span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">x = 100       # 整數
x = "hello"   # 變成字串
</pre>
<p><span style="background-color: #ffff99;">七、可同時宣告多個變數（多重賦值）</span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">a, b, c = 1, 2, 3
x = y = z = 0  # 所有變數都為 0
</pre>
<p></p>
<hr/>
<p>有關 w3 簡報</p>
<p><a href="/downloads/1a_w3_about_presentation.txt">1a_w3_about_presentation.txt</a></p>
<p>先處理<span style="background-color: #ccffcc;">奇數正方形網格區域</span>，讓機器人走過每一格: <a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/fa7d2a68d1569596f62e5b7739a83119/raw/295cc3af8240aa9b88f9c3a36b676f71135023fa/for_odd_square_grid_area.py">執行結果</a>。</p>
<p>針對<span style="background-color: #ccffcc;">長方形網格區域</span>，讓機器人也能走過每一格: <a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/fa7d2a68d1569596f62e5b7739a83119/raw/37d7b11d9da66ce781e11372b601fac28f1ee279/for_any_rectangle_grid_area.py">執行結果</a>。</p>
<hr/>
<p>w3: 什麼是 git, GitHub, gist 與 cmsimde? 如何使用這些工具？為什麼要使用這些工具？</p>
<hr/>
<p>原始提問:<br/><br/>下個禮拜我們這一組有六位組員，被要求要上台報告有關計算機程式課程的學習心得，題目是:w3: 什麼是 git，GitHub，gist 與 cmsimde? 如何使用這些工具？為什麼要使用這些工具？, 上課時老師只稍微說明一下，但要我們自己找資料聯席，並且六人逐一上台報告心得， 請用大一新生的程度，幫我們這六位組員準備講稿,並且準備六個人分別要上台展示的指令及內容, 講稿請詳細解說, 並列出參考網站來源, 非常感謝。<br/><br/>要求修飾提問稿:<br/><br/>請幫我們將以下的文字稍微整理一下, 讓他比較通順易懂: 下個禮拜我們這一組有六位組員，被要求要上台報告有關計算機程式課程的學習心得，題目是:w3: 什麼是 git，GitHub，gist 與 cmsimde? 如何使用這些工具？為什麼要使用這些工具？, 上課時老師只稍微說明一下，但要我們自己找資料聯席，並且六人逐一上台報告心得， 請用大一新生的程度，幫我們這六位組員準備講稿,並且準備六個人分別要上台展示的指令及內容, 講稿請詳細解說, 並列出參考網站來源, 非常感謝。<br/><br/>結果:<br/><br/>下個禮拜我們組有六位組員，會上台報告計算機程式課程的學習心得。報告的題目是：「W3: 什麼是 Git、GitHub、Gist 和 CMSIMDE？如何使用這些工具？為什麼要使用這些工具？」老師在課堂上簡單提過這些工具，但並沒有深入講解，並且要求我們自己搜尋資料，準備報告內容。我們的報告會分成六部分，每位組員負責介紹一個主題，逐一上台展示。<br/><br/>因此，請幫我們為六位組員準備講稿，內容要符合大一新生的理解程度，並且每個人要有具體的指令展示與解說。希望講稿能詳細說明這些工具的基本概念、操作方法及為什麼我們需要使用它們，並附上參考網站來源。<br/><br/>感謝你的幫忙！</p>
<p>其他相關提問:</p>
<p>請將以下的 markdown 轉為 html, 其中的 head 標註請用 h4 表示, 不要使用 h3, h2 或 h1。</p>
<p>請再更詳細說明每一個重點，並且列出能直接在電腦上邊操作邊說明的內容，以及操作步驟，還有操作展示的目的。</p>
<p>回覆內容請用 html 表示，而 head 標註請用 h4 表示, 不要使用 h3, h2 或 h1。</p>
<p data-pm-slice="1 1 []">請詳細說明，上述的議題與操作流程跟計算機程式課程有甚麼關係?使用這些工具有甚麼優點?若不使用又會怎樣?</p>
<hr/>
<p>參考回覆:</p>
<p>這是一次很好的學習機會，能夠深入了解 Git、GitHub、Gist 和 CMSIMDE 的使用和意義，並且學會如何在報告中表達這些技術對程式設計的影響。接下來，我會為你們準備一個詳細的講稿，並且安排好每位組員需要上台展示的內容。每個人的講稿會著重於解釋和展示基本概念與操作。</p>
<h4><strong>整體講稿大綱：</strong></h4>
<ol>
<li><strong>組員 1：什麼是 Git？</strong></li>
<li><strong>組員 2：Git 的基本命令與操作</strong></li>
<li><strong>組員 3：什麼是 GitHub？</strong></li>
<li><strong>組員 4：如何使用 GitHub 進行協作</strong></li>
<li><strong>組員 5：什麼是 Gist？</strong></li>
<li><strong>組員 6：CMSIMDE 和為什麼要使用 Git、GitHub 和 Gist</strong></li>
</ol>
<h4><strong>1. 組員 1：什麼是 Git？</strong></h4>
<p><strong>講稿內容：</strong></p>
<p>大家好，今天我將介紹 Git。Git 是一個分佈式版本控制系統（Version Control System, VCS），由 Linus Torvalds（Linux 的創始人）開發。它主要用來追蹤程式碼的變更，並且能夠幫助多人協作開發同一個專案。</p>
<ul>
<li><strong>版本控制：</strong> Git 讓你能夠對每次程式碼的變動進行記錄和管理，並且隨時回到歷史版本。這對於多人協作開發來說非常重要，因為每個人都能夠清楚地知道自己和別人對程式碼的修改。</li>
<li><strong>分佈式：</strong> Git 是分佈式的，這意味著每個開發者的電腦上都有一份完整的程式碼庫。即使離線也可以進行編輯和提交，後續再與其他開發者同步。</li>
</ul>
<p><strong>參考資料：</strong></p>
<ul>
<li><a href="https://git-scm.com/">Git 官方網站</a></li>
<li><a href="https://www.git-scm.com/book/zh-tw/v2">簡介：Git 是什麼？</a></li>
</ul>
<hr/>
<h4><strong>2. 組員 2：Git 的基本命令與操作</strong></h4>
<p><strong>講稿內容：</strong></p>
<p>接下來，我將介紹 Git 的基本命令和操作。這些命令幾乎是每個程式開發者日常必學的。</p>
<ol>
<li><strong>初始化 Git 倉庫（初始化 repository）：</strong><br/> <code>git init</code><br/> 這個命令會創建一個新的 Git 倉庫，用來追蹤程式碼變更。</li>
<li><strong>檢查狀態：</strong><br/> <code>git status</code><br/> 用來檢查當前的版本控制狀態，例如哪些檔案已被修改、哪些尚未加入 Git 追蹤。</li>
<li><strong>添加文件到版本控制：</strong><br/> <code>git add &lt;檔案名&gt;</code><br/> 把修改的文件加入 Git 追蹤，這樣下一次提交時，Git 會記錄這些變更。</li>
<li><strong>提交變更：</strong><br/> <code>git commit -m "提交訊息"</code><br/> 用來將變更提交到本地的 Git 倉庫中，並附上描述這次修改的訊息。</li>
<li><strong>查看提交歷史：</strong><br/> <code>git log</code><br/> 用來查看所有提交的歷史紀錄。</li>
</ol>
<p><strong>參考資料：</strong></p>
<ul>
<li><a href="https://backlog.com/git-tutorial/cn/">Git 入門指南</a></li>
<li><a href="https://www.runoob.com/git/git-command-ref.html">Git 常用命令</a></li>
</ul>
<hr/>
<h4><strong>3. 組員 3：什麼是 GitHub？</strong></h4>
<p><strong>講稿內容：</strong></p>
<p>GitHub 是一個基於 Git 的雲端代碼託管平台。它可以讓開發者將本地的 Git 倉庫推送到雲端，並與其他人共享代碼。GitHub 使得程式碼存儲、協作和版本控制變得更加簡單和高效。</p>
<ul>
<li><strong>GitHub 的主要功能：</strong></li>
<ul>
<li><strong>代碼托管：</strong> GitHub 提供免費的代碼托管服務，可以讓開發者將程式碼儲存在雲端，並且輕鬆與他人共享。</li>
<li><strong>協作功能：</strong> 開發者可以通過 Fork、Pull Request 等功能來進行協作開發，這對於開源專案尤其重要。</li>
<li><strong>問題追蹤：</strong> GitHub 還有 Issues 功能，可以幫助團隊追蹤和管理程式中的 Bug 或新功能的開發。</li>
</ul>
</ul>
<p><strong>參考資料：</strong></p>
<ul>
<li><a href="https://github.com/">GitHub 官方網站</a></li>
<li><a href="https://guides.github.com/">GitHub 入門</a></li>
</ul>
<hr/>
<h4><strong>4. 組員 4：如何使用 GitHub 進行協作</strong></h4>
<p><strong>講稿內容：</strong></p>
<p>GitHub 是協作開發的利器。這裡，我們將介紹如何使用 GitHub 進行協作：</p>
<ol>
<li><strong>創建一個新的 GitHub 儲存庫（repository）：</strong><br/> 在 GitHub 上創建一個新的儲存庫，然後將本地的 Git 倉庫推送到這個儲存庫。<br/> <code>git remote add origin &lt;repository-url&gt;</code><br/> <code>git push -u origin master</code></li>
<li><strong>Fork 和 Pull Request：</strong><br/>
<ul>
<li><strong>Fork：</strong> 將他人的專案複製到自己的帳號下，這樣就可以在自己帳號中進行修改。</li>
<li><strong>Pull Request：</strong> 在修改完成後，通過 Pull Request 提交修改，向原作者請求合併（Merge）你的更改。</li>
</ul>
</li>
<li><strong>分支管理：</strong><br/> 在多人協作的情況下，通常每個開發者會創建自己的分支（branch），在完成開發後再合併（merge）到主分支。</li>
</ol>
<p><strong>參考資料：</strong></p>
<ul>
<li><a href="https://guides.github.com/activities/forking/">GitHub 協作指南</a></li>
<li><a href="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request">如何創建 Pull Request</a></li>
</ul>
<hr/>
<h4><strong>5. 組員 5：什麼是 Gist？</strong></h4>
<p><strong>講稿內容：</strong></p>
<p>Gist 是 GitHub 提供的一個簡單的代碼分享和存儲工具，主要用來分享片段代碼或日常的小範例。</p>
<ul>
<li><strong>Gist 的特點：</strong></li>
<ul>
<li>Gist 允許開發者輕鬆分享代碼片段，並且可以選擇是否公開或私密。</li>
<li>每個 Gist 都有一個唯一的 URL，方便分享給他人。</li>
<li>支援版本控制，並且可以對 Gist 進行 Fork 和修改。</li>
</ul>
</ul>
<p><strong>參考資料：</strong></p>
<ul>
<li><a href="https://gist.github.com/">Gist 官方網站</a></li>
<li><a href="https://help.github.com/en/github/creating-cloning-and-archiving-repositories/creating-gists">如何使用 Gist</a></li>
</ul>
<hr/>
<h4><strong>6. 組員 6：CMSIMDE 和為什麼要使用 Git、GitHub 和 Gist</strong></h4>
<p><strong>講稿內容：</strong></p>
<p>最後，我們來談談 CMSIMDE 以及為什麼我們要使用 Git、GitHub 和 Gist。</p>
<ul>
<li><strong>CMSIMDE（Content Management System and Integrated Development Environment）：</strong> 這是一個綜合的開發環境，旨在幫助開發者管理和開發程式。它融合了內容管理系統和集成開發環境的功能，可以更高效地協作開發和版本管理。</li>
<li><strong>為什麼要使用 Git、GitHub 和 Gist：</strong>
<ul>
<li><strong>版本控制：</strong> Git 和 GitHub 讓開發者能夠追蹤程式碼的變更，防止程式碼丟失，並且能夠隨時回到舊版本。</li>
<li><strong>協作開發：</strong> GitHub 和 Gist 使得多人協作開發變得更加順利，無論是協同編寫代碼還是討論功能需求，都能在 GitHub 上輕鬆實現。</li>
<li><strong>便於分享：</strong> 透過 Gist，開發者能夠迅速分享代碼片段或小範例，這對於學習和交流非常有幫助。</li>
</ul>
</li>
</ul>
<p><strong>參考資料：</strong></p>
<ul>
<li><a href="https://www.cmsimde.com/">CMSIMDE 介紹</a></li>
<li><a href="https://gist.github.com/">GitHub 和 Gist 介紹</a></li>
</ul>
<hr/>
<p>進一步提問，要求補充更多資料:</p>
<p>請再更詳細說明每一個重點，並且列出能直接在電腦上邊操作邊說明的內容，以及操作步驟，還有操作展示的目的。</p>
<p>回覆內容請用 html 表示，而 head 標註請用 h4 表示, 不要使用 h3, h2 或 h1。</p>
<hr/>
<p>這是一次很好的學習機會，能夠深入了解 Git、GitHub、Gist 和 CMSIMDE 的使用和意義，並且學會如何在報告中表達這些技術對程式設計的影響。接下來，我會為你們準備一個詳細的講稿，並且安排好每位組員需要上台展示的內容。每個人的講稿會著重於解釋和展示基本概念與操作。</p>
<h4><strong>整體講稿大綱：</strong></h4>
<ol>
<li><strong>組員 1：什麼是 Git？</strong></li>
<li><strong>組員 2：Git 的基本命令與操作</strong></li>
<li><strong>組員 3：什麼是 GitHub？</strong></li>
<li><strong>組員 4：如何使用 GitHub 進行協作</strong></li>
<li><strong>組員 5：什麼是 Gist？</strong></li>
<li><strong>組員 6：CMSIMDE 和為什麼要使用 Git、GitHub 和 Gist</strong></li>
</ol>
<h4><strong>1. 組員 1：什麼是 Git？</strong></h4>
<p><strong>講稿內容：</strong></p>
<p>大家好，今天我將介紹 Git。Git 是一個分佈式版本控制系統（Version Control System, VCS），由 Linus Torvalds（Linux 的創始人）開發。它的目的是追蹤程式碼的變更，並協助多人協作開發。</p>
<p>Git 的兩大特點：</p>
<ul>
<li><strong>版本控制：</strong> 每次程式碼的變動都會被記錄，並且能夠隨時回到歷史版本。這樣即使有錯誤，也能夠快速恢復程式碼。</li>
<li><strong>分佈式：</strong> 每個開發者的電腦上都會有一份完整的程式碼庫，這讓開發者能夠在離線的情況下進行編輯，並在有網路時再進行同步。</li>
</ul>
<h4><strong>操作展示：</strong></h4>
<p><strong>目的：</strong> 理解 Git 如何管理程式碼版本並進行變更追蹤。</p>
<p>請依照下列步驟在電腦中實際操作：</p>
<ol>
<li><strong>建立一個新的 Git 倉庫：</strong>
<p>在你的終端機（Terminal）中，創建一個新的資料夾，然後初始化 Git 倉庫：</p>
<code>mkdir my_project &amp;&amp; cd my_project</code><br/> <code>git init</code>
<p>這個命令會創建一個新的 Git 倉庫。</p>
</li>
<li><strong>查看 Git 狀態：</strong>
<p>使用命令檢查當前 Git 倉庫的狀態：</p>
<code>git status</code>
<p>這會顯示哪些檔案有變更，但尚未被 Git 追蹤。</p>
</li>
<li><strong>創建檔案並提交變更：</strong>
<p>創建一個簡單的檔案：</p>
<code>echo "Hello, Git!" &gt; hello.txt</code><br/>
<p>然後使用以下命令將檔案添加到 Git 追蹤：</p>
<code>git add hello.txt</code><br/>
<p>最後提交變更：</p>
<code>git commit -m "Add hello.txt"</code></li>
</ol>
<h4><strong>2. 組員 2：Git 的基本命令與操作</strong></h4>
<p><strong>講稿內容：</strong></p>
<p>接下來，我將介紹 Git 的基本命令，這些是開發過程中最常使用的命令。</p>
<ul>
<li><strong>git init：</strong> 用來初始化一個新的 Git 倉庫。</li>
<li><strong>git add：</strong> 用來將修改過的檔案添加到 Git 追蹤列表。</li>
<li><strong>git commit：</strong> 用來提交檔案，將變更保存到版本庫。</li>
<li><strong>git status：</strong> 查看當前的工作區狀態，顯示檔案是否有變更。</li>
<li><strong>git log：</strong> 查看提交歷史。</li>
</ul>
<h4><strong>操作展示：</strong></h4>
<p><strong>目的：</strong> 熟悉並實際操作 Git 的基本命令。</p>
<p>請依照下列步驟在電腦中進行：</p>
<ol>
<li><strong>查看工作區狀態：</strong>
<p>使用命令檢查當前工作區的狀態：</p>
<code>git status</code></li>
<li><strong>查看 Git 提交歷史：</strong>
<p>顯示最近的提交紀錄：</p>
<code>git log</code>
<p>可以使用 `q` 退出日誌查看。</p>
</li>
</ol>
<h4><strong>3. 組員 3：什麼是 GitHub？</strong></h4>
<p><strong>講稿內容：</strong></p>
<p>GitHub 是基於 Git 的代碼託管平台，可以讓開發者將本地的 Git 倉庫上傳到雲端，並與其他人共享代碼。</p>
<ul>
<li><strong>代碼托管：</strong> GitHub 允許免費或付費的方式來儲存你的代碼，並可以方便地與他人協作。</li>
<li><strong>協作功能：</strong> 例如 Fork、Pull Request，這些功能使得開發者能夠在開源項目中協作。</li>
<li><strong>問題追蹤：</strong> GitHub 提供 Issues 功能，方便開發團隊追蹤問題和進度。</li>
</ul>
<h4><strong>操作展示：</strong></h4>
<p><strong>目的：</strong> 演示如何在 GitHub 上創建和管理倉庫。</p>
<p>請依照下列步驟操作：</p>
<ol>
<li><strong>創建 GitHub 倉庫：</strong>
<p>進入 GitHub 網站，點選 "New Repository" 並創建一個新的倉庫。</p>
</li>
<li><strong>將本地倉庫推送到 GitHub：</strong>
<p>在終端機中，執行以下命令：</p>
<code>git remote add origin https://github.com/yourusername/your-repository.git</code><br/> <code>git push -u origin master</code></li>
</ol>
<h4><strong>4. 組員 4：如何使用 GitHub 進行協作</strong></h4>
<p><strong>講稿內容：</strong></p>
<p>GitHub 使多人協作變得簡單。這裡介紹如何在 GitHub 上協作開發。</p>
<ul>
<li><strong>Fork：</strong> 將他人的倉庫複製到你的 GitHub 帳號下，這樣你就可以自由修改。</li>
<li><strong>Pull Request：</strong> 當你完成修改後，向原始倉庫發送 Pull Request 請求合併你的變更。</li>
<li><strong>分支管理：</strong> 每個開發者可以創建自己的分支來進行開發，避免直接修改主分支。</li>
</ul>
<h4><strong>操作展示：</strong></h4>
<p><strong>目的：</strong> 演示如何使用 GitHub 進行協作開發。</p>
<p>請依照下列步驟操作：</p>
<ol>
<li><strong>Fork 一個倉庫：</strong>
<p>在 GitHub 上找到一個開源專案，點選 "Fork" 將其複製到你的帳號。</p>
</li>
<li><strong>創建 Pull Request：</strong>
<p>修改 Fork 的倉庫後，點選 "Pull Request" 發送合併請求。</p>
</li>
</ol>
<h4><strong>5. 組員 5：什麼是 Gist？</strong></h4>
<p><strong>講稿內容：</strong></p>
<p>Gist 是 GitHub 提供的一個工具，讓開發者可以分享小片段的代碼或文檔。</p>
<h4><strong>操作展示：</strong></h4>
<p><strong>目的：</strong> 演示如何創建和分享 Gist。</p>
<p>請依照下列步驟操作：</p>
<ol>
<li><strong>創建 Gist：</strong>
<p>進入 Gist 網站，點選 "Create Gist"，並粘貼你想分享的代碼。</p>
</li>
<li><strong>分享 Gist：</strong>
<p>創建完後，你會獲得一個唯一的 URL，可以將這個 URL 分享給其他人。</p>
</li>
</ol>
<h4><strong>6. 組員 6：CMSIMDE 和為什麼要使用 Git、GitHub 和 Gist</strong></h4>
<p><strong>講稿內容：</strong></p>
<p>這部分將介紹 CMSIMDE 並討論使用 Git、GitHub 和 Gist 的重要性。</p>
<ul>
<li><strong>版本控制：</strong> 使用 Git 可以讓開發者記錄代碼的變更並輕鬆回滾。</li>
<li><strong>協作開發：</strong> GitHub 和 Gist 是協作開發的好工具，能讓多人輕鬆協同工作。</li>
<li><strong>簡化分享：</strong> 使用 Gist 可以快速分享代碼片段和文件。</li>
</ul>
<p>這些工具對於開發流程非常有幫助，無論是學習、開發還是協作，都能大大提高效率。</p>
<hr/>
<h4><strong>請詳細說明，上述的議題與操作流程跟計算機程式課程有甚麼關係?使用這些工具有甚麼優點?若不使用又會怎樣?</strong></h4>
<h4><strong>Git、GitHub、Gist 和 CMSIMDE 與計算機程式課程的關係</strong></h4>
<p>在計算機程式設計課程中，學習如何編寫程式、協作開發、管理程式碼變更，以及有效地共享代碼是非常重要的。Git、GitHub、Gist 和 CMSIMDE 是一些現代開發中不可或缺的工具，它們不僅有助於程式開發過程的管理，還能提高開發效率，促進團隊協作。以下將詳細說明這些工具與計算機程式課程的關係，以及它們的優點，並分析如果不使用這些工具可能帶來的後果。</p>
<h4><strong>1. Git 與程式設計課程的關係</strong></h4>
<p><strong>Git</strong> 是一個強大的版本控制工具，主要用來追蹤程式碼的變更，確保開發過程中的每個修改都有記錄，並且能夠隨時回到先前的版本。對於程式設計課程來說，Git 可以幫助學生管理自己的程式碼版本，防止在編寫程式時發生錯誤丟失，並且讓學生能夠在團隊合作中協同開發。</p>
<h4><strong>操作流程：</strong></h4>
<p><strong>目的：</strong> 學生使用 Git 來管理自己的程式碼變更和協作開發。</p>
<ol>
<li><strong>初始化本地倉庫：</strong>
<p>在學生開始編寫程式碼時，使用 `git init` 創建一個本地 Git 倉庫，開始管理程式碼的版本。</p>
</li>
<li><strong>提交程式碼：</strong>
<p>每當學生進行了一些變更（如修正錯誤或增加功能），可以使用 `git add` 和 `git commit` 來記錄和保存這些變更。</p>
</li>
<li><strong>查看變更歷史：</strong>
<p>學生可以使用 `git log` 查看所有的提交歷史，了解程式碼的變更情況。</p>
</li>
</ol>
<h4><strong>優點：</strong></h4>
<ul>
<li><strong>版本控制：</strong> Git 允許學生記錄每一次的程式碼變更，並能隨時回到歷史版本，這對於避免錯誤和修改衝突非常重要。</li>
<li><strong>協作開發：</strong> 在團隊專案中，Git 使得每個組員都能在自己的工作區域編寫程式碼，並能夠在需要時將自己的變更推送到主倉庫。</li>
</ul>
<h4><strong>不使用 Git 的後果：</strong></h4>
<ul>
<li><strong>程式碼丟失：</strong> 若學生不使用 Git，當程式碼出現錯誤或變更不當時，無法輕易回到之前的版本，可能會浪費大量時間來修復錯誤。</li>
<li><strong>難以協作：</strong> 團隊協作將變得困難，因為每個人可能會在不同的版本上工作，無法輕鬆合併所有的變更，甚至會導致代碼衝突。</li>
</ul>
<h4><strong>2. GitHub 與程式設計課程的關係</strong></h4>
<p><strong>GitHub</strong> 是基於 Git 的雲端代碼託管平台，提供在線存儲和版本控制服務。GitHub 的協作功能使得學生能夠將自己的程式碼上傳至雲端，並且與其他組員共享、協作開發，這對於程式設計課程中的團隊專案開發尤為重要。</p>
<h4><strong>操作流程：</strong></h4>
<p><strong>目的：</strong> 學生將本地程式碼推送到 GitHub 上，並通過協作功能進行合作開發。</p>
<ol>
<li><strong>創建 GitHub 倉庫：</strong>
<p>學生可以在 GitHub 上創建一個新倉庫，並將本地倉庫與之連接，通過 `git remote add` 和 `git push` 把程式碼推送到 GitHub。</p>
</li>
<li><strong>Fork 和 Pull Request：</strong>
<p>學生可以 Fork 他人的專案，修改後再向原專案發送 Pull Request，請求將修改合併到主專案中。</p>
</li>
</ol>
<h4><strong>優點：</strong></h4>
<ul>
<li><strong>協作功能：</strong> GitHub 使得學生能夠進行多人協作，並且能夠清晰地管理和合併不同組員的變更。</li>
<li><strong>雲端儲存：</strong> GitHub 提供雲端儲存，學生可以隨時訪問自己的程式碼，並且不需要擔心資料丟失。</li>
</ul>
<h4><strong>不使用 GitHub 的後果：</strong></h4>
<ul>
<li><strong>協作困難：</strong> 如果不使用 GitHub，學生之間的程式碼協作將變得繁瑣，難以管理變更，也難以追蹤問題。</li>
<li><strong>無法便捷共享：</strong> 學生無法像 GitHub 一樣方便地向他人展示自己的代碼，協作和交流會受到限制。</li>
</ul>
<h4><strong>3. Gist 與程式設計課程的關係</strong></h4>
<p><strong>Gist</strong> 是 GitHub 提供的代碼片段分享平台，適合學生分享小範圍的代碼段或程式設計題目的解法。Gist 使得學生能夠輕鬆展示學習過程中的代碼片段或共享一些學習心得。</p>
<h4><strong>操作流程：</strong></h4>
<p><strong>目的：</strong> 學生使用 Gist 快速分享代碼片段或小範例。</p>
<ol>
<li><strong>創建 Gist：</strong>
<p>學生可以將代碼片段粘貼到 Gist 網站，創建公開或私有的 Gist，並將其分享給其他人。</p>
</li>
</ol>
<h4><strong>優點：</strong></h4>
<ul>
<li><strong>代碼分享：</strong> 學生可以輕鬆分享自己的學習代碼片段，這對於同學之間的學習交流非常有幫助。</li>
<li><strong>簡單的版本控制：</strong> Gist 會自動為每個代碼片段建立版本控制，學生可以追蹤代碼的歷史變化。</li>
</ul>
<h4><strong>不使用 Gist 的後果：</strong></h4>
<ul>
<li><strong>難以分享學習成果：</strong> 學生如果不使用 Gist，將難以快速分享自己的代碼片段，學習過程中也無法有效地與他人進行交流。</li>
<li><strong>代碼存儲混亂：</strong> 代碼可能會散落在不同的地方，難以集中管理和查詢。</li>
</ul>
<h4><strong>4. CMSIMDE 與程式設計課程的關係</strong></h4>
<p><strong>CMSIMDE</strong> 是一種綜合開發環境，它融合了內容管理系統和集成開發環境（IDE）的功能，提供一個集中式的開發平台。在程式設計課程中，CMSIMDE 可以幫助學生更高效地開發、管理和協作程式碼。</p>
<h4><strong>優點：</strong></h4>
<ul>
<li><strong>提高開發效率：</strong> CMSIMDE 提供了一個統一的開發環境，學生可以在一個平台上進行編程、調試和版本管理，避免多重工具之間的切換。</li>
<li><strong>集成協作工具：</strong> CMSIMDE 可能包含像 GitHub 等協作工具，幫助學生進行多人協作開發。</li>
</ul>
<h4><strong>不使用 CMSIMDE 的後果：</strong></h4>
<ul>
<li><strong>開發效率低：</strong> 如果學生沒有使用 CMSIMDE，他們將需要在多個工具和平台之間切換，這會浪費時間並降低效率。</li>
<li><strong>難以協作：</strong> 沒有 CMSIMDE，學生將難以在一個平台上集中管理開發、測試和版本控制，協作會變得更加複雜。</li>
</ul><h1>Examples</h1>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<div id="brython_div1"></div>
<p>w5: <span>深入理解</span><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/fa7d2a68d1569596f62e5b7739a83119/raw/e2502768ea4e0d13b33da0976b656a337e51ad42/cp_w4_robot_animation.py">機器人行走模擬程式</a><span>中的所有 Python 與 Brython 程式用法。</span></p>
<p><span style="background-color: #ffff00;">目前頁面已經有一個 div 標註, 其 id 設為 brython_div1, 請多舉幾個 brython browser 模組的 document, html, timer 以及 bind 的範例, 各舉十個範例, 讓我可以交作業.</span></p><h2>w5_1</h2>
<p>How can the robot be controlled via keyboard input from a remote user?</p>
<p><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/fa7d2a68d1569596f62e5b7739a83119/raw/e2502768ea4e0d13b33da0976b656a337e51ad42/cp_w4_robot_animation.py">機器人行走模擬程式</a></p>
<p style="padding-left: 30px;"><a href="/downloads/brython_robot_websocket.txt">brython_robot_websocket.txt</a></p>
<p style="padding-left: 30px;"><a href="/downloads/websocket_server.py">websocket_server.py</a></p>
<p>在頁面中嵌入 Brython 執行環境:</p>
<p style="padding-left: 30px;"><a href="/downloads/editor_embed_brython.txt">editor_embed_brython.txt</a></p>
<div id="brython_div1"></div>
<!-- 導入 brython 程式庫 -->
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
</p>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
<script type="text/python3">
from browser import document, html, timer, bind

# 每個格子的像素大小
CELL_SIZE = 40

# 牆壁厚度，用於圖片位置調整
WALL_THICKNESS = 6

# 牆壁與機器人圖片的來源路徑
IMG_PATH = "https://mde.tw/cp2025/reeborg/src/images/"

# --- 定義世界地圖的類別 ---
class World:
    def __init__(self, width, height):
        self.width = width    # 地圖寬度（格子數）
        self.height = height  # 地圖高度（格子數）
        self.layers = self._create_layers()  # 建立多層 canvas 物件（背景、牆、物體、機器人）
        self._init_html()      # 初始化 HTML 容器
        self._draw_grid()      # 畫出網格線
        self._draw_walls()     # 畫出邊界牆壁

    def _create_layers(self):
        # 建立四個繪圖層，用於不同物件
        return {
            "grid": html.CANVAS(width=self.width * CELL_SIZE, height=self.height * CELL_SIZE),
            "walls": html.CANVAS(width=self.width * CELL_SIZE, height=self.height * CELL_SIZE),
            "objects": html.CANVAS(width=self.width * CELL_SIZE, height=self.height * CELL_SIZE),
            "robots": html.CANVAS(width=self.width * CELL_SIZE, height=self.height * CELL_SIZE),
        }

    def _init_html(self):
        # 建立容器 DIV，將四層 Canvas 疊起來
        container = html.DIV(style={
            "position": "relative",
            "width": f"{self.width * CELL_SIZE}px",
            "height": f"{self.height * CELL_SIZE}px"
        })

        for z, canvas in enumerate(self.layers.values()):
            canvas.style = {
                "position": "absolute",
                "top": "0px",
                "left": "0px",
                "zIndex": str(z)
            }
            container <= canvas

        # 手機用控制按鈕 UI
        button_container = html.DIV(style={"margin-top": "10px", "text-align": "center"})
        move_button = html.BUTTON("Move Forward (j)", id="move_button")
        turn_button = html.BUTTON("Turn Left (i)", id="turn_button")
        button_container <= move_button
        button_container <= turn_button

        # 插入到 HTML 指定位置
        document["brython_div1"].clear()
        document["brython_div1"] <= container
        document["brython_div1"] <= button_container

    def _draw_grid(self):
        # 畫格線
        ctx = self.layers["grid"].getContext("2d")
        ctx.strokeStyle = "#cccccc"
        for i in range(self.width + 1):
            ctx.beginPath()
            ctx.moveTo(i * CELL_SIZE, 0)
            ctx.lineTo(i * CELL_SIZE, self.height * CELL_SIZE)
            ctx.stroke()
        for j in range(self.height + 1):
            ctx.beginPath()
            ctx.moveTo(0, j * CELL_SIZE)
            ctx.lineTo(self.width * CELL_SIZE, j * CELL_SIZE)
            ctx.stroke()

    def _draw_image(self, ctx, src, x, y, w, h, offset_x=0, offset_y=0):
        # 載入圖片並繪製（用於牆壁、機器人）
        img = html.IMG()
        img.src = src
        def onload(evt):
            px = x * CELL_SIZE + offset_x
            py = (self.height - 1 - y) * CELL_SIZE + offset_y  # Y軸向上翻轉
            ctx.drawImage(img, px, py, w, h)
        img.bind("load", onload)

    def _draw_walls(self):
        # 畫四邊的牆壁
        ctx = self.layers["walls"].getContext("2d")
        for x in range(self.width):
            self._draw_image(ctx, IMG_PATH + "north.png", x, self.height - 1, CELL_SIZE, WALL_THICKNESS)
            self._draw_image(ctx, IMG_PATH + "north.png", x, 0, CELL_SIZE, WALL_THICKNESS, offset_y=CELL_SIZE - WALL_THICKNESS)
        for y in range(self.height):
            self._draw_image(ctx, IMG_PATH + "east.png", 0, y, WALL_THICKNESS, CELL_SIZE)
            self._draw_image(ctx, IMG_PATH + "east.png", self.width - 1, y, WALL_THICKNESS, CELL_SIZE, offset_x=CELL_SIZE - WALL_THICKNESS)

    def robot(self, x, y):
        # 畫出靜態機器人（初始位置）
        ctx = self.layers["robots"].getContext("2d")
        self._draw_image(ctx, IMG_PATH + "blue_robot_e.png", x - 1, y - 1, CELL_SIZE, CELL_SIZE)

# --- 定義動畫機器人類別 ---
class AnimatedRobot:
    def __init__(self, world, x, y):
        self.world = world
        self.x = x - 1
        self.y = y - 1
        self.facing = "E"  # 初始朝向
        self.facing_order = ["E", "N", "W", "S"]
        self.robot_ctx = world.layers["robots"].getContext("2d")
        self.trace_ctx = world.layers["objects"].getContext("2d")
        self.queue = []  # 動作佇列
        self.running = False
        self._draw_robot()

    def _robot_image(self):
        return {
            "E": "blue_robot_e.png",
            "N": "blue_robot_n.png",
            "W": "blue_robot_w.png",
            "S": "blue_robot_s.png"
        }[self.facing]

    def _draw_robot(self):
        self.robot_ctx.clearRect(0, 0, self.world.width * CELL_SIZE, self.world.height * CELL_SIZE)
        self.world._draw_image(self.robot_ctx, IMG_PATH + self._robot_image(), self.x, self.y, CELL_SIZE, CELL_SIZE)

    def _draw_trace(self, from_x, from_y, to_x, to_y):
        # 繪製路徑線條
        ctx = self.trace_ctx
        ctx.strokeStyle = "#d33"
        ctx.lineWidth = 2
        ctx.beginPath()
        fx = from_x * CELL_SIZE + CELL_SIZE / 2
        fy = (self.world.height - 1 - from_y) * CELL_SIZE + CELL_SIZE / 2
        tx = to_x * CELL_SIZE + CELL_SIZE / 2
        ty = (self.world.height - 1 - to_y) * CELL_SIZE + CELL_SIZE / 2
        ctx.moveTo(fx, fy)
        ctx.lineTo(tx, ty)
        ctx.stroke()

    def move(self, steps):
        def action(next_done):
            def step():
                nonlocal steps
                if steps == 0:
                    next_done()
                    return
                from_x, from_y = self.x, self.y
                dx, dy = 0, 0
                if self.facing == "E":
                    dx = 1
                elif self.facing == "W":
                    dx = -1
                elif self.facing == "N":
                    dy = 1
                elif self.facing == "S":
                    dy = -1
                next_x = self.x + dx
                next_y = self.y + dy

                if 0 <= next_x < self.world.width and 0 <= next_y < self.world.height:
                    self.x, self.y = next_x, next_y
                    self._draw_trace(from_x, from_y, self.x, self.y)
                    self._draw_robot()
                    steps -= 1
                    timer.set_timeout(step, 200)
                else:
                    print("已經撞牆，停止移動！")
                    next_done()
            step()
        self.queue.append(action)
        self._run_queue()

    def turn_left(self):
        def action(done):
            idx = self.facing_order.index(self.facing)
            self.facing = self.facing_order[(idx + 1) % 4]
            self._draw_robot()
            timer.set_timeout(done, 300)
        self.queue.append(action)
        self._run_queue()

    def _run_queue(self):
        if self.running or not self.queue:
            return
        self.running = True
        action = self.queue.pop(0)
        action(lambda: self._done())

    def _done(self):
        self.running = False
        self._run_queue()

# --- 主程式：建立地圖與機器人 ---
w = World(10, 10)
w.robot(1, 1)
r = AnimatedRobot(w, 1, 1)

# 綁定鍵盤控制
@bind(document, "keydown")
def keydown(evt):
    if evt.key == "j":
        r.move(1)
    elif evt.key == "i":
        r.turn_left()

# 綁定按鈕控制
@bind(document["move_button"], "click")
def move_click(evt):
    r.move(1)

@bind(document["turn_button"], "click")
def turn_click(evt):
    r.turn_left()

# 初始自動巡邏路線（可移除）
r.move(9)
r.turn_left()
r.move(9)
r.turn_left()
r.move(9)
r.turn_left()
r.move(9)
</script>
</p>
<h2>w7</h2>
<p><a href="/downloads/websocket_robot.7z">websocket_robot.7z</a></p>
<h2>w10</h2>
<p>程式開發說明:</p>
<p style="padding-left: 30px;">請使用 Python 透過 ORM 套件 <strong>Peewee</strong> 連接並建立一個名為 <strong>stud2.sqlite</strong> 的 SQLite 資料庫，其資料表需包含 <code>index</code>, <code>account</code>, <code>password</code>, <code>studnum</code>, <code>memo</code> 等欄位，其中 <code>index</code> 為自動遞增主鍵（從 1 開始），<code>account</code> 欄位的內容為從 <code>a1</code> 到 <code>a500</code> 共 500 筆資料，<code>password</code> 欄位需以不易混淆的英文字母（A–Z）與數字（0–9）組成，並利用亂數方式產生 4 位字元的密碼，<code>studnum</code> 與 <code>memo</code> 欄位預設留空。</p>
<p style="padding-left: 30px;">建立該資料庫的程式請命名為 <strong>createdb.py</strong>，並於檔案開頭以註解說明執行本程式前必須安裝的模組（例如 <code>peewee</code>、<code>random</code> 等）及注意事項。</p>
<p style="padding-left: 30px;">接著，請再撰寫另一支使用 <strong>Python + Flask + Peewee ORM</strong> 的應用程式，該程式需建立一個具兩階段驗證流程的網頁系統：第一階段提供使用者輸入通關密碼的頁面，若輸入正確的通關密碼 <code>"thepassword"</code>，則進入第二階段的表單頁面；若輸入錯誤，則顯示 <code>"抱歉, 請洽管理者!"</code> 訊息，停留三秒後自動跳回密碼輸入頁面。</p>
<p style="padding-left: 30px;">在第二階段頁面中，使用者需選擇課程選項（可選項目為 <code>1a</code>, <code>1b</code>, <code>2a</code>, <code>2b</code>），並輸入學號與姓名。當使用者送出資料後，系統需連接 <strong>course_num_name2.sqlite</strong> 資料庫（其欄位包含 <code>index</code>, <code>course</code>, <code>number</code>, <code>name</code>），查詢與使用者所選課程及輸入的學號、姓名相符的資料；若比對正確，則從 <strong>stud2.sqlite</strong> 中找出尚未填入 <code>studnum</code> 的帳號，顯示其 <code>account</code> 與 <code>password</code> 資料，並提示使用者以手機拍下該畫面；隨後，將該筆帳號的 <code>studnum</code> 欄位更新為使用者輸入的學號。</p>
<p style="padding-left: 30px;">整體流程中，<strong>createdb.py</strong> 為建立 Linux 登入帳號與密碼資料庫的程式，而第二支 Flask 程式則用於驗證課程、學號、姓名後，自動發放對應的登入帳密，並依據 <strong>course_num_name2.sqlite</strong> 的內容進行比對。最後，請先建立一個空的 <strong>course_num_name2.sqlite</strong> 資料庫檔案以供後續資料匯入，並從 <strong>stud2.sqlite</strong> 中擷取所有的 <code>account</code> 與 <code>password</code> 欄位資料，將其以 <strong>Tab</strong> 符號分隔後，輸出至文字檔 <strong>account_password2.txt</strong>。</p>
<p>Python 與 SQLite 資料庫:</p>
<p>create_empty_course_db.py</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import sqlite3  # 引入 sqlite3 模組，用於與 SQLite 資料庫進行互動

conn = sqlite3.connect('course_num_name.sqlite')  # 連接或創建名為 'course_num_name.sqlite' 的 SQLite 資料庫
cursor = conn.cursor()  # 創建一個游標物件，後續的 SQL 操作會通過這個游標執行

# 創建表格 'course_num_name'，如果表格已存在則不再創建
cursor.execute('''
CREATE TABLE IF NOT EXISTS course_num_name (  # 如果資料表 'course_num_name' 不存在，則創建
    id INTEGER PRIMARY KEY AUTOINCREMENT,  # id 欄位為自動遞增的整數，作為主鍵
    course TEXT,  # course 欄位，儲存課程編號，型別為 TEXT
    number TEXT,  # number 欄位，儲存課程編號，型別為 TEXT
    name TEXT  # name 欄位，儲存課程名稱，型別為 TEXT
);
''')

conn.commit()  # 提交對資料庫的所有變更，將創建的表格儲存到資料庫中
conn.close()  # 關閉資料庫連線，釋放資源

print("空的 course_num_name.sqlite 資料庫已建立！")  # 輸出成功訊息，告知資料庫已成功建立
</pre>
<p>createdb.py</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># createdb.py
# 執行此程式前需要安裝以下模組：
# pip install peewee   # Peewee 是一個輕量級 ORM（Object Relational Mapping）工具，用於操作資料庫
# pip install random   # random 是 Python 內建模組，其實無需安裝，但此註解提醒要使用隨機數功能

import random  # 匯入 random 模組，用於生成隨機密碼
import string  # 匯入 string 模組，用於取得英文字母與數字字元
from peewee import *  # 從 peewee 模組中匯入所有類別與方法，以便定義資料庫模型

# 設定 SQLite 資料庫，建立或連接名為 'stud2.sqlite' 的資料庫
db = SqliteDatabase('stud2.sqlite')

# 定義資料表模型 Student，繼承自 peewee 的 Model 類別
class Student(Model):
    account = CharField(unique=True)  # 帳號欄位，使用文字型別（CharField），且設為唯一（unique=True）
    password = CharField()  # 密碼欄位，使用文字型別
    studnum = CharField(null=True)  # 學號欄位，允許為空值（null=True）
    memo = CharField(null=True)  # 備註欄位，允許為空值

    class Meta:
        database = db  # 指定此模型所使用的資料庫為上方建立的 db

# 建立資料庫連線
db.connect()
# 在資料庫中建立 Student 資料表（若不存在）
db.create_tables([Student])

# 定義一個隨機生成密碼的函數
def generate_password():
    chars = string.ascii_uppercase + string.digits  # 定義可用字元（A-Z 與 0-9）
    return ''.join(random.choice(chars) for _ in range(4))  # 隨機挑選 4 個字元並組合成密碼

# 使用 for 迴圈插入 500 筆資料
for i in range(1, 501):  # 從 1 執行到 500（共 500 次）
    account = f'a{i}'  # 帳號名稱為 a1, a2, a3, ..., a500
    password = generate_password()  # 產生隨機密碼
    # 建立 Student 資料表中的一筆新資料（插入帳號與密碼）
    Student.create(account=account, password=password)

print("資料庫已建立並插入 500 筆帳號資料！")  # 顯示成功訊息，表示已成功建立資料庫與資料
</pre>
<p></p>
<p>add_course_field_to_stud2_db.py</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># add_course_column.py
from peewee import *  # 匯入 peewee 模組的所有內容，用於定義與操作 SQLite 資料庫模型

# 設定資料庫連接
db = SqliteDatabase('stud2.sqlite')  # 指定資料庫為 stud2.sqlite，若不存在則會自動建立

# 定義學生資料表模型 Student，對應資料庫中的 Student 資料表
class Student(Model):
    id = AutoField()  # 自動遞增的整數欄位，作為主鍵（PRIMARY KEY）
    course = CharField()  # 新增的課程欄位，用來儲存課程名稱或代碼
    account = CharField(unique=True)  # 帳號欄位，設為唯一（unique=True）
    password = CharField()  # 密碼欄位，使用文字型別
    studnum = CharField(null=True)  # 學號欄位，可允許為空值
    memo = CharField(null=True)  # 備註欄位，可允許為空值
    inner_port = IntegerField(null=True)  # 新增的內部連接埠欄位，可允許為空值
    outter_port = IntegerField(null=True)  # 新增的外部連接埠欄位，可允許為空值

    class Meta:
        database = db  # 指定該模型所屬的資料庫

# 啟動資料庫連線
db.connect()

# 檢查 Student 資料表是否已存在，若不存在則自動建立
if not Student.table_exists():
    db.create_tables([Student])  # 建立 Student 資料表

# 更新資料表結構的說明（此段程式實際上未直接修改結構）
# 若資料表已存在且想新增 'course' 欄位，peewee 不支援自動修改現有表結構，
# 通常需透過手動 SQL ALTER TABLE 指令或使用資料遷移工具（如 playhouse.migrate）完成
print("Successfully added 'course' column to 'Student' table.")  # 顯示成功訊息，提示欄位已新增（僅提示性訊息）

# 關閉資料庫連線以釋放資源
db.close()
</pre>
<p></p>
<p>extract_account_password.py</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># extract_account_password.py
from peewee import *  # 匯入 peewee 模組中的所有功能，用來與 SQLite 資料庫互動

# 設定資料庫連接，指定使用 'stud2.sqlite' 資料庫
db = SqliteDatabase('stud2.sqlite')

# 定義 Student 資料表模型，對應資料庫中的 Student 表
class Student(Model):
    account = CharField(unique=True)  # 帳號欄位，使用文字型別並設定唯一性（unique=True）
    password = CharField()  # 密碼欄位，使用文字型別
    studnum = CharField(null=True)  # 學號欄位，可允許為空值
    memo = CharField(null=True)  # 備註欄位，可允許為空值

    class Meta:
        database = db  # 指定該模型所屬的資料庫

# 透過 Peewee ORM 查詢 Student 資料表中的所有資料
students = Student.select()

# 開啟（或建立）名為 'account_password.txt' 的文字檔，以寫入模式（'w'）開啟
with open('account_password2.txt', 'w') as file:
    # 使用迴圈逐筆讀取資料
    for student in students:
        # 將每位學生的帳號與密碼以「帳號&lt;TAB&gt;密碼」的格式寫入文字檔中
        file.write(f'{student.account}\t{student.password}\n')

# 完成後輸出訊息，提示帳號與密碼已成功匯出
print("帳號與密碼已寫入 account_password2.txt")
</pre>
<p></p>
<p>save_course_number_name_into_db.py</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from peewee import *
import os

# 設定資料庫連接
db = SqliteDatabase('course_num_name2.sqlite')

# 定義課程資料表模型
class Course(Model):
    course = CharField()  # 課程名稱（例如 1a）
    number = CharField()  # 學號
    name = CharField()    # 姓名

    class Meta:
        database = db

# 設置資料庫連接
db.connect()

# 確保資料表存在
db.create_tables([Course])

# 讀取檔案並寫入資料庫的函式
def import_course_data(filename, course_name):
    try:
        # 讀取檔案
        with open(filename, 'r', encoding='utf-8') as file:
            for line in file:
                # 拆分每行的學號和姓名
                parts = line.strip().split('\t')  # 使用 tab 拆分
                if len(parts) == 2:  # 確保每行資料都有學號和姓名
                    number, name = parts
                    # 寫入資料庫
                    Course.create(course=course_name, number=number, name=name)
                    print(f"已將 {number} - {name} 寫入資料庫")
    except Exception as e:
        print(f"讀取檔案 {filename} 時發生錯誤: {e}")

# 依次讀取各個檔案並寫入資料庫
file_list = ['1a_num_name2.txt', '1b_num_name2.txt', '2a_num_name2.txt', '2b_num_name2.txt']
for file in file_list:
    course_name = file.split('_')[0]  # 取檔名的第一部分作為課程名稱
    if os.path.exists(file):
        import_course_data(file, course_name)
    else:
        print(f"檔案 {file} 不存在！")
</pre>
<p>add_inner_outter_ports.py</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># 更新 stud2.sqlite 資料庫，為 student 表新增 inner_port 和 outter_port 欄位，並自動填入值
from peewee import *
import sqlite3

# 連接到現有資料庫
db = SqliteDatabase('stud2.sqlite')

# 定義學生資料表模型
class Student(Model):
    id = AutoField()
    account = CharField(unique=True)
    password = CharField()
    studnum = CharField(null=True)
    memo = CharField(null=True)
    inner_port = IntegerField(null=True)   # 內部端口
    outter_port = IntegerField(null=True)  # 外部端口

    class Meta:
        database = db

# 1. 連接資料庫
db.connect()

# 2. 確保資料表存在
db.create_tables([Student])

# 3. 新增欄位 (SQLite 支援 ALTER TABLE ADD COLUMN)
with db.atomic():
    db.execute_sql('ALTER TABLE student ADD COLUMN inner_port INTEGER')
    db.execute_sql('ALTER TABLE student ADD COLUMN outter_port INTEGER')

# 4. 為每筆學生資料分配內外部端口
students = Student.select()
inner_port_value = 8001
outter_port_value = 9001

for student in students:
    student.inner_port = inner_port_value
    student.outter_port = outter_port_value
    student.save()
    inner_port_value += 1
    outter_port_value += 1

print("資料已更新，已成功為每筆資料新增內外部端口！")
</pre>
<p>readd_course_field_to_stud2_db.py</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import sqlite3

# 連接資料庫
conn = sqlite3.connect('stud2.sqlite')
cursor = conn.cursor()

# 創建新的資料表 student_new，加入 course 欄位
cursor.execute('''
    CREATE TABLE IF NOT EXISTS student_new (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        course TEXT NOT NULL,
        account TEXT UNIQUE,
        password TEXT,
        studnum TEXT,
        memo TEXT,
        inner_port INTEGER,
        outter_port INTEGER
    )
''')

# 將舊資料表 student 的資料搬移到 student_new，course 欄位先填空字串
cursor.execute('''
    INSERT INTO student_new (course, account, password, studnum, memo, inner_port, outter_port)
    SELECT '', account, password, studnum, memo, inner_port, outter_port FROM student
''')

# 刪除舊資料表
cursor.execute('DROP TABLE IF EXISTS student')

# 將新資料表重新命名為舊資料表名稱
cursor.execute('ALTER TABLE student_new RENAME TO student')

# 提交更改並關閉資料庫
conn.commit()
conn.close()

print("資料表結構已經更新，並成功新增 'course' 欄位。")
</pre>
<p></p>
<p>app.py</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from flask import Flask, render_template, request, redirect, url_for
from peewee import *
import sqlite3

# 設定資料庫連接
db = SqliteDatabase('stud2.sqlite')

# 定義學生資料表模型
class Student(Model):
    id = AutoField()             # 自動生成主鍵欄位
    course = CharField()         # 課程欄位
    account = CharField(unique=True)
    password = CharField()
    studnum = CharField(null=True)
    memo = CharField(null=True)
    inner_port = IntegerField(null=True)
    outter_port = IntegerField(null=True)

    class Meta:
        database = db

# 定義 Flask 應用
app = Flask(__name__)

# 第一階段的通關密碼
CORRECT_PASSWORD = "thepassword"

# 首頁路由
@app.route('/')
def home():
    return render_template('login.html')

# 驗證第一階段密碼
@app.route('/validate_password', methods=['POST'])
def validate_password():
    entered_password = request.form.get('password')
    if entered_password == CORRECT_PASSWORD:
        return redirect(url_for('course_selection'))
    return render_template('login.html', error="抱歉, 請洽管理者!")

# 課程選擇頁面
@app.route('/course_selection')
def course_selection():
    return render_template('course_selection.html')

# 處理課程選擇與分配帳號
@app.route('/submit_course', methods=['POST'])
def submit_course():
    selected_course = request.form.get('course')
    student_number = request.form.get('studnum')
    student_name = request.form.get('name')

    # 查詢 course 資料庫
    conn = sqlite3.connect('course_num_name2.sqlite')
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM course WHERE course=? AND number=? AND name=?', 
                   (selected_course, student_number, student_name))
    result = cursor.fetchone()
    conn.close()

    if not result:
        return "資料錯誤，請洽管理者"

    # 檢查是否已分配
    student = Student.select().where(Student.studnum==student_number, Student.course==selected_course).first()
    if student:
        return render_template('login.html', error="已經分配過，若有問題請洽管理者.")

    # 找出尚未分配的帳號
    student_to_assign = Student.select().where(Student.studnum.is_null()).first()
    if not student_to_assign:
        return render_template('login.html', error="所有帳號已經被分配，請洽管理者.")

    # 分配學號與課程
    student_to_assign.studnum = student_number
    student_to_assign.course = selected_course
    student_to_assign.save()

    # 顯示帳號、密碼、端口與說明
    return render_template('show_account.html',
                           account=student_to_assign.account,
                           password=student_to_assign.password,
                           inner_port=student_to_assign.inner_port,
                           outter_port=student_to_assign.outter_port,
                           explanation=f"""
                           請利用帳號 {student_to_assign.account} 及密碼 {student_to_assign.password} 登入 s5.eng.nfu.edu.tw。&lt;br/&gt;
                           指令為: ssh {student_to_assign.account}@s5.eng.nfu.edu.tw，輸入由英文大寫字母與數字所組成的密碼後登入。&lt;br /&gt;&lt;br /&gt;
                           登入後將 {student_to_assign.inner_port} 設定在 server.py 後，&lt;br /&gt;
                           您將可以透過 &lt;a href="https://s5.eng.nfu.edu.tw:{student_to_assign.outter_port}"&gt;https://s5.eng.nfu.edu.tw:{student_to_assign.outter_port}&lt;/a&gt; 連線至動態編輯網頁，&lt;br /&gt;&lt;br /&gt;
                           並使用 &lt;a href="https://s5.eng.nfu.edu.tw/~{student_to_assign.account}"&gt;https://s5.eng.nfu.edu.tw/~{student_to_assign.account}&lt;/a&gt; 連線至帳號下的 public_html 目錄中的靜態網頁資料。&lt;br /&gt;&lt;br /&gt;
                           請隨即&lt;strong&gt;利用手機拍下本頁面資料&lt;/strong&gt;，在本學期課程結束前保護好您的帳號與密碼，並確認所有埠號設定正確。""")

# 管理者帳號登入
@app.route('/alogin', methods=['GET', 'POST'])
def alogin():
    if request.method == 'POST':
        account = request.form.get('account')
        password = request.form.get('password')
        if account == "theaccount" and password == "thepassword":
            return render_template('find_studnum.html')
        return render_template('alogin.html', error="帳號或密碼錯誤")
    return render_template('alogin.html')

# 查詢 studnum
@app.route('/find_studnum', methods=['POST'])
def find_studnum():
    studnum = request.form.get('studnum')
    students = Student.select().where(Student.studnum.contains(studnum))
    if students:
        return render_template('show_multiple_students.html', students=students)
    return render_template('find_studnum.html', error="未找到對應的學生資料")

if __name__ == '__main__':
    app.run(debug=True)
</pre>
<p></p>
<p>templates/login.html</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;!DOCTYPE html&gt;
&lt;html lang="zh"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;登入頁面&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h2&gt;請輸入通關密碼&lt;/h2&gt;
    &lt;form method="POST" action="/validate_password"&gt;
        &lt;input type="password" name="password" required&gt;
        &lt;button type="submit"&gt;送出&lt;/button&gt;
    &lt;/form&gt;
    {% if error %}
        &lt;p&gt;{{ error }}&lt;/p&gt;
    {% endif %}
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p></p>
<p>templates/course_selection.html</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;!DOCTYPE html&gt;
&lt;html lang="zh"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;課程選擇&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h2&gt;選擇課程&lt;/h2&gt;
    &lt;form method="POST" action="/submit_course"&gt;
     修課班級:
        &lt;select name="course"&gt;
            &lt;option value="1a"&gt;1a&lt;/option&gt;
            &lt;option value="1b"&gt;1b&lt;/option&gt;
            &lt;option value="2a"&gt;2a&lt;/option&gt;
            &lt;option value="2b"&gt;2b&lt;/option&gt;
        &lt;/select&gt;&lt;br&gt;&lt;br&gt;
        學號: &lt;input type="text" name="studnum" placeholder="學號" required&gt;&lt;br&gt;&lt;br&gt;
        姓名: &lt;input type="text" name="name" placeholder="姓名" required&gt;&lt;br&gt;&lt;br&gt;
        &lt;button type="submit"&gt;送出&lt;/button&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p></p>
<p>show_account.html</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;!DOCTYPE html&gt;
&lt;html lang="zh"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;顯示帳號密碼&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h2&gt;帳號與密碼&lt;/h2&gt;
    &lt;p&gt;&lt;strong&gt;帳號:&lt;/strong&gt; {{ account }}&lt;/p&gt;
    &lt;p&gt;&lt;strong&gt;密碼:&lt;/strong&gt; {{ password }}&lt;/p&gt;
    &lt;p&gt;&lt;strong&gt;內部端口 (inner_port):&lt;/strong&gt; {{ inner_port }}&lt;/p&gt;
    &lt;p&gt;&lt;strong&gt;外部端口 (outter_port):&lt;/strong&gt; {{ outter_port }}&lt;/p&gt;
    &lt;p&gt;{{ explanation|safe }}&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p><a href="/downloads/2025_cp_project.7z">2025_cp_project.7z</a></p><h1>Projects</h1>
<p><a href="https://flask.palletsprojects.com/en/stable/">Flask</a> + <a href="https://brython.info/">Brython</a> (<a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/fa7d2a68d1569596f62e5b7739a83119/raw/d1f7266329c2e18800c236f8c639b1de0317a591/cp_w4_robot_animation.py">robot_lib.py</a>) + <a href="https://docs.peewee-orm.com/en/latest/">Peewee</a> + <a href="https://sqlite.org/">SQLite</a> (<a href="https://www.mysql.com/">MySQL</a>, <a href="https://www.postgresql.org/">PostgreSQL</a>)</p>
<p><a href="/downloads/brython_proj_stage1.7z">brython_proj_stage1.7z</a></p>
<p><a href="/downloads/brython_proj.7z">brython_proj.7z</a></p>
<p><a href="/downloads/db_browser.7z.001">db_browser.7z.001</a></p>
<p><a href="/downloads/db_browser.7z.002">db_browser.7z.002</a></p>
<p><a href="/downloads/db_browser.7z.003">db_browser.7z.003</a></p>
<p>取得 Ubuntu 操作系統上的帳號: <a href="https://s5.eng.nfu.edu.tw:9500">https://s5.eng.nfu.edu.tw:9500</a> </p>
<p>線上 Brython 程式環境: <a href="https://s5.eng.nfu.edu.tw:9499/">https://s5.eng.nfu.edu.tw:9499/</a> </p>
<p><img caption="false" height="394" src="/images/cp_2025_project.png" width="500"/></p>
<p>期末分組專案示範:</p>
<p>從 <a href="https://s5.eng.nfu.edu.tw:9499/brython_test?load=432">https://s5.eng.nfu.edu.tw:9499/brython_test?load=432</a> 簡單的瀏覽器前端程式，延伸至 <a href="https://github.com/mdecycu/cp_final_ex">https://github.com/mdecycu/cp_final_ex</a> </p>
<p>w14-w18: Python (Flask)，Brython，Peewee (ORM)，SQLite</p>
<p style="padding-left: 30px;">Brython 程式環境: </p>
<p style="padding-left: 60px;"><a href="https://s5.eng.nfu.edu.tw:9499/">https://s5.eng.nfu.edu.tw:9499/</a> (部署到 Linux)</p>
<p style="padding-left: 60px;"><a href="https://github.com/mdecycu/brython_proj">https://github.com/mdecycu/brython_proj</a> (原始碼)</p>
<p style="padding-left: 30px;">英雄榜: </p>
<p style="padding-left: 60px;"><a href="https://s5.eng.nfu.edu.tw:9498/">https://s5.eng.nfu.edu.tw:9498/</a> (部署到 Linux)</p>
<p style="padding-left: 60px;"><a href="https://github.com/mdecycu/cp_final_ex">https://github.com/mdecycu/cp_final_ex</a> (原始碼)</p>
<p style="padding-left: 60px;">如何修改:</p>
<p style="padding-left: 90px;">憤怒鳥與三隻小豬 (用投石器擊潰小豬房舍得分)</p>
<p style="padding-left: 90px;"><a href="/downloads/angrybird_stage1.7z">angrybird_stage1.7z</a></p>
<p style="padding-left: 90px;"><a href="/downloads/angrybird_stage2.7z">angrybird_stage2.7z</a></p>
<p style="padding-left: 90px;">投籃比賽 (投球機構分別投出隨機重量，不同距離的籃框得分)</p>
<hr/>
<p>怒鳥 x 三隻小豬<br/><br/>除了「擊潰房舍」之外，可以加入：<br/><br/>1. 破壞效率得分（工程能量概念）<br/><br/>玩家使用的拉距（向量長度）越短 → 分數係數越高<br/><br/>使用最少的彈射能量達成破壞 → 類似「最節能工程師獎」<br/><br/>2. 不同材料的建築（教育點：剛性 vs 韌性）<br/><br/>房舍材料可隨機或逐關：<br/><br/>木材（易斷）<br/><br/>磚塊（堅硬但脆）<br/><br/>鋼材（高強度但難破壞）<br/><br/>泡綿（吸能而不倒）<br/><br/>→ 玩家要學會調整發射角度與力量，才能找出 最佳撞擊點。<br/><br/>3. 加入風（向量合力）<br/><br/>像高級關卡：<br/><br/>加風向（顯示箭頭）<br/><br/>讓發射軌跡被偏移<br/><br/>玩家必須考慮：<br/>合力 = 發射向量 + 風力向量<br/><br/>4. 建築結構弱點（破壞力學示意）<br/><br/>目標房舍可以加入「弱點」：<br/><br/>連接點<br/><br/>支撐柱<br/><br/>重心<br/><br/>若玩家擊中弱點 →額外得分<br/>讓玩家學到結構力學的基本原理。<br/><br/>5. 多種彈射球（材料力學教育）<br/><br/>重球（高動能）<br/><br/>軟球（不易破壞）<br/><br/>彈力球（反彈後可二段攻擊）<br/><br/>粗糙球（撞擊後不滑動）<br/><br/>B. 投籃比賽（加入工程機構 + 隨機重量系統）<br/><br/>你提出的「投球機構投出不同重量球、不同距離有不同分數」很棒，還可以加入：<br/><br/>1. 球重量隨機 → 玩家需調整角度+力道（向量概念）<br/><br/>例如：<br/><br/>輕球 → 飛得遠<br/><br/>重球 → 掉得快<br/><br/>可以在畫面顯示：<br/><br/>球重量圖示<br/><br/>建議「速度 vs 角度」提示（教育內容）<br/><br/>2. 風阻 / 空氣阻力（速度衰減）<br/><br/>讓玩家體驗阻力方程式的效果，但以簡化版呈現：<br/><br/>vx *= 0.98<br/>vy *= 0.98<br/><br/>3. 多籃框、不同角度與高度（工程射擊設計）<br/><br/>偏左、偏右<br/><br/>高籃框（需要更大角度）<br/><br/>移動籃框（反應力學+預判）<br/><br/>4. 多種投球機構（遊戲可玩性 up）<br/><br/>玩家可選：<br/><br/>彈射器<br/><br/>彈弓<br/><br/>壓縮彈簧槍（力學公式：E=1/2 kx²）<br/><br/>空壓投球器（可加入空壓示意）<br/><br/>不同機構對應不同的「力量來源」。<br/><br/>5. 連續 combo（操作技巧提升）<br/><br/>如果玩家：<br/><br/>連續命中 2 次 → 力量誤差加倍<br/><br/>連續命中 3 次 → 投射準心變大<br/><br/>增加競技性。<br/><br/>C. 其他可行的類憤怒鳥 + 工程力學遊戲設計<br/><br/>以下是你可以加入到平台中的新遊戲模式（同樣用滑鼠操作、輕量向量力學）：<br/><br/>1. 工程投射擂台（向量角度 + 能量優化）<br/><br/>玩家需要讓球落在指定「工程目標區」內：<br/><br/>Zone A：高角度反射<br/><br/>Zone B：低速度精準<br/><br/>Zone C：滑行距離最長<br/><br/>教育點：<br/><br/>投射角影響水平距離<br/><br/>滑動與摩擦力概念<br/><br/>動能 → 滑行距離<br/><br/>2. 拆除工程師（精準點破壞）<br/><br/>像破壞磚塊遊戲：<br/><br/>結構內有多個節點（Nodes）<br/><br/>玩家選擇用多少「力」攻擊哪個節點<br/><br/>物理反應可能是：<br/><br/>破壞後塔倒塌<br/><br/>重心偏移後自己崩壞（很爽 XD）<br/><br/>教育點：<br/><br/>結構剛度<br/><br/>最佳攻擊點<br/><br/>3. 拋射運輸系統（控制角度搬運物體）<br/><br/>玩家射出小車/小球，要把它送到指定平台：<br/><br/>過低會掉下去<br/><br/>過高會撞到障礙<br/><br/>太快會彈飛<br/><br/>有點像「工程跨越」的概念。<br/><br/>4. 風場拋物線（合力可視化）<br/><br/>畫面中有風力場（用箭頭表示）<br/>玩家射出的球會被風帶走。<br/><br/>可加入：<br/><br/>升力版本（像紙飛機飛更遠）<br/><br/>下沉區（重力場）<br/><br/>教育點：<br/>合力向量 F = ΣFi<br/><br/>5. 彈射賽車（速度向量 + 碰撞）<br/><br/>玩家用彈弓把車射出去，<br/>看誰滑得最遠。<br/><br/>加入：<br/><br/>地面摩擦分區<br/><br/>沙地、冰塊、水坑<br/><br/>彈跳坡道（動能 → 位能 → 動能）<br/><br/>D. 其他功能：<br/>排行榜<br/>回放（儲存向量→重播）<br/>限時賽（最短時間通過關卡）<br/>最少能量（拉最短的距離破壞）<br/>每日挑戰（隨機風 + 隨機重量）</p><h2>9499</h2>
<p>線上 Brython 程式環境: <a href="https://s5.eng.nfu.edu.tw:9499/">https://s5.eng.nfu.edu.tw:9499/</a> (僅支援 IPv6 網路)</p>
<p>查看程式: <a href="https://s5.eng.nfu.edu.tw:9499/programs">https://s5.eng.nfu.edu.tw:9499/programs</a>  (僅支援 IPv6 網路)</p>
<p style="padding-left: 30px;"><a href="https://s5.eng.nfu.edu.tw:9499/brython_test?load=22">w12 課堂分組作業</a> (請在 600x400 pixel 畫布中, 畫出國旗順時針分別旋轉 90度與 45度的圖像)</p>
<p style="padding-left: 30px;"><a href="https://s5.eng.nfu.edu.tw:9499/brython_test?load=179">w12 課堂分組作業</a> (請修正)</p>
<p style="padding-left: 30px;"><a href="https://s5.eng.nfu.edu.tw:9499/brython_test?load=39">Openduck mini 組立</a></p>
<p style="padding-left: 30px;"><a href="https://s5.eng.nfu.edu.tw:9499/brython_test?load=38">顯示具材質 3D 零件</a></p>
<p style="padding-left: 30px;"><a href="https://s5.eng.nfu.edu.tw:9499/brython_test?load=180">機器人行走模擬七段數字顯示器</a></p>
<p style="padding-left: 30px;"><a href="https://s5.eng.nfu.edu.tw:9499/brython_test?load=183">數值分析解常微分方程式</a></p>
<p style="padding-left: 30px;"><a href="https://s5.eng.nfu.edu.tw:9499/brython_test?load=184">鋼球磁浮系統自動控制</a></p>
<p>之後的改版可以套用: <a href="https://github.com/PrairieLearn/PrairieLearn">https://github.com/PrairieLearn/PrairieLearn</a> 建立更多線上課題或繪圖內容。</p>
<p>強制由 Brython 帶入的 ace.js 編輯區使用四個 spaces 進行縮排:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">class Editor:
    def __init__(self, editor_id, console_id, container_id, storage_id):
        self.editor_id = editor_id
        self.console_id = console_id
        self.container_id = container_id
        self.storage_id = storage_id
        try:
            self.editor = window.ace.edit(self.editor_id)
            session = self.editor.getSession()
            session.setMode("ace/mode/python")
            # 強制使用四個 spaces 區隔縮排
            session.setTabSize(4)
            session.setUseSoftTabs(True)
            self.editor.setOptions({
                'enableLiveAutocompletion': True,
                'enableSnippets': True,
                'highlightActiveLine': False,
                'highlightSelectedWord': True,
                'autoScrollEditorIntoView': True,
                'maxLines': 30,
                'fontSize': '13px'
            })
        except:
            self.editor = html.TEXTAREA(rows=20, cols=70)
            doc[self.editor_id] &lt;= self.editor
            def get_value(): return self.editor.value
            def set_value(x): self.editor.value = x
            self.editor.getValue = get_value
            self.editor.setValue = set_value</pre>
<p></p><h2>9500</h2>
<p>取得 Ubuntu 操作系統上的帳號: <a href="https://s5.eng.nfu.edu.tw:9500">https://s5.eng.nfu.edu.tw:9500</a>  (僅支援 IPv6 網路)</p>
<p>如何使用 Ubuntu 操作系統?</p>
<p style="padding-left: 30px;">Windows 與 Ubuntu 之間的檔案互通: 使用 <a href="https://portableapps.com/apps/internet/filezilla_portable">Portable Filezilla</a>，下載後以 7zip 解開壓縮檔案後，放入隨身碟中的 portable_filezilla 目錄後即可使用。</p>
<p style="padding-left: 30px;">不同操作系統間可以透過 SFTP 協定互通檔案，server 端為 Openssh 伺服器，若 Windows 為專業版可以自行安裝，Openssh 客戶端則內建於 Windows 與 Linux 操作系統。</p>
<p style="padding-left: 30px;">Ubuntu 操作系統可以透過 sudo apt install openssh-server 安裝伺服器。</p>
<p></p><h1>Brython</h1>
<p><a href="https://brython.info/">Brython</a> 是一個將 <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> 語法編譯為 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript">JavaScript</a> 的工具，能直接在瀏覽器中以 <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> 撰寫前端網頁程式。</p>
<p><button id="add1to100">1 add to 100</button><button id="robot1">機器人巡邏</button><button id="free_walk">自由行</button></p>
<!-- 導入 brython 程式庫 -->
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
</p>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫 -->
<script src="/static/Cango-24v03-min.js"></script>
<script src="/static/gearUtils-09.js"></script>
<script src="/static/SVGpathUtils-6v03-min.js"></script>
<script src="/static/sylvester.js"></script>
<script src="/static/PrairieDraw.js"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p><!-- 累加程式開始 -->
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()
Ace1 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run1():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src"]
    except:
        url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c3a6deaf717f8f2739a4b1392a5ab10936e9693a/from_1_add_to_10_1.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace1.editor.setValue(prog)
    Ace1.editor.scrollToRow(0)
    Ace1.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace1.run()
# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run1'].bind('click', Ace1.run)
doc['kw_show_console1'].bind('click', Ace1.show_console)
doc['kw_clear_console1'].bind('click', Ace1.clear_console)
doc['clear_bd1'].bind('click', clear_bd1)
# 呼叫函式執行
run1()
</script>
<!-- 累加程式結束 --> <!-- 機器人巡邏程式開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

robot1_url = "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/b33c5fc2a0774f8c5d2b0e8c7c7908e58d73bb94/robot_1.py"

# 從 gist 取得程式碼
robot1_src = open(robot1_url).read()
def robot1(ev):
    Ace2.editor.setValue(robot1_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "robot1" 的按鈕點按時, 執行 robot1 方法
doc["robot1"].bind('click', robot1)
</script>
<!-- 機器人巡邏程式結束 --></p>
<!-- 機器人自由行程式開始 -->
<p>
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

free_walk_url = "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9d55811467e411eb89f74171d8a586ae9f1a96aa/brython_robot_free_walk.py"

# 從 gist 取得程式碼
free_walk_src = open(free_walk_url).read()
def free_walk(ev):
    Ace2.editor.setValue(free_walk_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "free_walk" 的按鈕點按時, 執行 robot1 方法
doc["free_walk"].bind('click', free_walk)
</script>
</p>
<!-- 機器人自由行程式結束 -->
<p><!-- add 1 to 100 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

add1to100_url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add(ev):
    Ace2.editor.setValue(add_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "add1to100" 的按鈕點按時, 執行 add 方法
doc["add1to100"].bind('click', add)
</script>
</p>
<p><!-- add 1 to 100 結束--></p>
<!-- editor1 開始 -->
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor1" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src1', 'kw_filename1');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run1">Run</button> <button id="kw_show_console1">Output</button> <button id="kw_clear_console1">清除輸出區</button><button id="clear_bd1">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console1"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div1"></div>
<!-- editor1 結束 --><hr/><!-- ########################################## -->
<p>從 1 累加到 100 part2:</p>
<p><button id="add1to100part2">1 add to 100</button><button id="cango_three_gears">cango_three_gears</button><button id="bsnake">BSnake</button><button id="aitetris">AI Tetris</button></p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd2(ev):
    bd = doc["brython_div2"]
    bd.clear()
Ace3 = ace.Editor(editor_id="kw_editor2", console_id="kw_console2", container_id="kw__container2", storage_id="kw_py_src2" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run2():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src2"]
    except:
        url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c3a6deaf717f8f2739a4b1392a5ab10936e9693a/from_1_add_to_10_1.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace3.editor.setValue(prog)
    Ace3.editor.scrollToRow(0)
    Ace3.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace3.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run2'].bind('click', Ace3.run)
doc['kw_show_console2'].bind('click', Ace3.show_console)
doc['kw_clear_console2'].bind('click', Ace3.clear_console)
doc['clear_bd2'].bind('click', clear_bd2)
# 呼叫函式執行
run2()
</script>
</p>
<p><!-- add 1 to 100 part2 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd2(ev):
    bd = doc["brython_div2"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace4 = ace.Editor(editor_id="kw_editor2", console_id="kw_console2", container_id="kw__container2", storage_id="kw_py_src2" )

# 透過 Ace4 以類別建立一個通用的 button2, 可以在多個案例中將 gist 程導入編輯區

class button2:
    def __init__(self, url):
        self.url = url

    # 記得加入 event 輸入變數
    def do(self,ev):
        Ace4.editor.setValue(open(self.url).read())
        Ace4.editor.scrollToRow(0)
        Ace4.editor.gotoLine(0)
        Ace4.run()

add1to100_url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add2(ev):
    Ace4.editor.setValue(add_src)
    Ace4.editor.scrollToRow(0)
    Ace4.editor.gotoLine(0)
    Ace4.run()

# id 為 "add1to100part2" 的按鈕點按時, 執行 add 方法
doc["add1to100part2"].bind('click', add2)
# 以下為運用 button2 class 的通用 gist 程式導入區
################################## cango_three_gears start
cango_three_gears_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/cango_three_gears_brython_div2.py"
cango_three_gears = button2(cango_three_gears_url)
doc["cango_three_gears"].bind("click", cango_three_gears.do)
################################## cango_three_gears end
################################## bsnake start
bsnake_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/kmol_snakey.py"
bsnake = button2(bsnake_url)
doc["bsnake"].bind("click", bsnake.do)
################################## bsnake end
################################## aitetris start
aitetris_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/pygame_to_brython_tetris_ai.py"
aitetris = button2(aitetris_url)
doc["aitetris"].bind("click", aitetris.do)
################################## aitetris end
</script>
</p>
<p><!-- add 1 to 100 part2 結束--></p>
<!-- editor2 開始 -->
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor2" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename2" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src2', 'kw_filename2');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run2">Run</button> <button id="kw_show_console2">Output</button> <button id="kw_clear_console2">清除輸出區</button><button id="clear_bd2">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console2"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div2"></div>
<!-- editor2 結束 --><hr/>
<p></p><h2>Pyodide3</h2>
<p>Pyodide3 則在 <a href="https://mde.tw/cp2025/content/Pyodide.html">Pyodide</a> 與 <a href="https://mde.tw/cp2025/content/Pyodide2.html">Pyodide2</a> 頁面架構下，進一步導入 <a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9f43571ec070ea3e24b083525ee27275a96efcc8/robot_w_world.py">robot_w_world.py</a>，在既有的水平圍牆 <a href="https://mde.tw/cp2025/reeborg/src/images/north.png">north.png</a> 與垂直圍牆 <a href="https://mde.tw/cp2025/reeborg/src/images/east.png">east.png</a> 檔案之外，加入 <a href="https://mde.tw/cp2025/reeborg/src/images/carrot.png">carrot.png</a>、<a href="https://mde.tw/cp2025/reeborg/src/images/grass.png">grass.png</a> 與 <a href="https://mde.tw/cp2025/reeborg/src/images/pale_grass.png">pale_grass.png</a> 等圖檔。並且擴充可從 URL 讀進 json 格式的 world 變數功能，以便製作出更多元的場景任務，要求機器人執行。</p>
<p>其中 src URL 變數，可以將網路上的機器人控制程式導入 Pyodide3 頁面外，world URL 變數則可以導入源自 <a href="https://mde.tw/reeborg">Reeborg</a> 機器人程式所設定的 json 格式場景。</p>
<p>由於 Reeborg 系統中的 png 圖檔均非透明背景，<a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9f43571ec070ea3e24b083525ee27275a96efcc8/robot_w_world.py">robot_w_world.py</a> 必須利用 HTML 中的 CANVAS，將關鍵的白色背景，以透明的方式顯示。</p>
<p>src URL 變數讀進 <a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/8ac3ce859d6aec327b7859e091168270d6a951f7/pyodide2_turn_right.py">turn_right 程式</a>，而 world URL 變數則讀進 <a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/43517f3f54a5ac24d55d5a5cf8d316e6db2f3b65/harvest2.json">harvest2.json</a>，執行<a href="https://mde.tw/cp2025/content/Pyodide3.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/8ac3ce859d6aec327b7859e091168270d6a951f7/pyodide2_turn_right.py&amp;world=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/43517f3f54a5ac24d55d5a5cf8d316e6db2f3b65/harvest2.json">結果</a>。</p>
<p>讀進 <a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/1b1c26eca7f5d772c6301bae865efaddb00a87bb/harvest3.json">harvest3.json</a>, 執行<a href="https://mde.tw/cp2025/content/Pyodide3.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/8ac3ce859d6aec327b7859e091168270d6a951f7/pyodide2_turn_right.py&amp;world=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9f43571ec070ea3e24b083525ee27275a96efcc8/harvest3.json">結果</a>。</p>
<p>
<script src="https://cdn.jsdelivr.net/pyodide/v0.26.4/full/pyodide.js"></script>
</p>
<p><button id="version">version</button> <button id="hello_button">hello</button> <button id="add1to100">1 add to 100</button> <button id="robot1">機器人巡邏</button> <button id="free_walk">自由行</button> <button id="numpy_ode">numpy_ode</button></p>
<!-- Ace Editor Scripts -->
<p>
<script src="/static/ace/FileSaver.min.js"></script>
<script src="/static/ace/filereader.js"></script>
<script src="/static/ace/ace.js"></script>
<script src="/static/ace/ext-language_tools.js"></script>
<script src="/static/ace/mode-python.js"></script>
<script src="/static/ace/snippets/python.js"></script>
</p>
<!-- Editor 1 -->
<div id="kw_editor1" style="width: 600px; height: 300px;"></div>
<p><button id="kw_run1">Run</button> <button id="kw_output1">Output</button> <button id="kw_clear_console1">清除輸出區</button> <button onclick="location.reload()">Reload</button></p>
<p><textarea id="kw_console1"></textarea></p>
<div id="pyodide_div1"></div>
<div id="mpl_output1"></div>
<div id="brython_div1"></div>
<hr/>
<p>從 1 累加到 100 part2:</p>
<p><button id="add1to100part2">1 add to 100</button></p>
<!-- Editor 2 -->
<div id="kw_editor2" style="width: 600px; height: 300px;"></div>
<p><button id="kw_run2">Run</button> <button id="kw_output2">Output</button> <button id="kw_clear_console2">清除輸出區</button> <button onclick="location.reload()">Reload</button></p>
<p><textarea id="kw_console2"></textarea></p>
<div id="pyodide_div2"></div>
<div id="mpl_output2"></div>
<div id="brython_div2"></div>
<p>
<script>
function getUrlParam(key) {
  return new URLSearchParams(window.location.search).get(key);
}
function updateUrlParam(key, value) {
  const url = new URL(window.location);
  url.searchParams.set(key, value);
  window.history.replaceState({}, "", url);
}

let pyodide, editor1, editor2;

// 新增：把 robot_w_world.py 寫入 pyodide FS
async function loadRobotModule() {
  const robotUrl = "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9f43571ec070ea3e24b083525ee27275a96efcc8/robot_w_world.py";
  const r = await fetch(robotUrl);
  if (!r.ok) throw new Error(`載入 robot.py 失敗: ${r.status}`);
  const code = await r.text();
  pyodide.FS.writeFile("/robot.py", code);
  pyodide.runPython(`import sys; sys.path.append("/")`);  // 加入根目錄到 sys.path
}

document.addEventListener("DOMContentLoaded", async () => {
  editor1 = ace.edit("kw_editor1");
  editor1.setTheme("ace/theme/chrome");
  editor1.session.setMode("ace/mode/python");

  editor2 = ace.edit("kw_editor2");
  editor2.setTheme("ace/theme/chrome");
  editor2.session.setMode("ace/mode/python");

  pyodide = await loadPyodide();
  await pyodide.loadPackage(["numpy", "scipy", "matplotlib", "micropip"]);

  // 預先載入 robot.py
  await loadRobotModule();

  // 你現有的 hello() 定義
  const code = `
def hello():
    print("Hello from custom module!")
`;
  pyodide.runPython(code);

  // 這是你之前其他按鈕用的 Gist 連結
  const GIST_ADD1TO100 =
    "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/" +
    "c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py";
  const NUMPY_ODE =
    "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/" +
    "98d582539545b3c9fbfa35dd3e605c506367618e/pyodide_ode_ex1.py";
  const PYODIDE_ROBOT_ANIMATION =
    "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/" +
    "ff833d14181c7e270d37432aa8589f5ecf00e383/pyodide_walk_around2.py";
  const FREE_WALK = 
    "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/" + "2a66dceb4a1dbdd0c384d4d17453f1e4f03f2493/pyodide_free_walk2.py"

  // 預設載入 GIST_ADD1TO100（或 URL 參數決定）
  const src = getUrlParam("src");
  if (src === PYODIDE_ROBOT_ANIMATION) {
    const robotCode = await fetchCode(PYODIDE_ROBOT_ANIMATION);
    editor1.setValue(robotCode, -1);
    updateUrlParam("src", PYODIDE_ROBOT_ANIMATION);
    runPyodide(editor1, "kw_console1", "brython_div1");
  } else {
    const initialCode = await fetchCode(src || GIST_ADD1TO100);
    editor1.setValue(initialCode, -1);
    runPyodide(editor1, "kw_console1", "brython_div1");
  }

  editor2.setValue("", -1);

  // 按鈕事件
  document.getElementById("version").onclick = () => {
    const vcode = `
import pyodide
import sys
import matplotlib
import numpy
import scipy
print("Pyodide version:", pyodide.__version__)
print("Python version :", sys.version)
print("matplotlib version:", matplotlib.__version__)
print("numpy version:", numpy.__version__)
print("scipy version:", scipy.__version__)
`;
    editor1.setValue(vcode, -1);
    updateUrlParam("src", "inline_version");
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("hello_button").onclick = () => {
    editor1.setValue("hello()", -1);
    updateUrlParam("src", "inline_hello");
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("add1to100").onclick = async () => {
    const c = await fetchCode(GIST_ADD1TO100);
    editor1.setValue(c, -1);
    updateUrlParam("src", GIST_ADD1TO100);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("numpy_ode").onclick = async () => {
    const c = await fetchCode(NUMPY_ODE);
    editor1.setValue(c, -1);
    updateUrlParam("src", NUMPY_ODE);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("robot1").onclick = async () => {
    const rc = await fetchCode(PYODIDE_ROBOT_ANIMATION);
    editor1.setValue(rc, -1);
    updateUrlParam("src", PYODIDE_ROBOT_ANIMATION);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("free_walk").onclick = async () => {
    const rc = await fetchCode(FREE_WALK);
    editor1.setValue(rc, -1);
    updateUrlParam("src", FREE_WALK);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("add1to100part2").onclick = async () => {
    const c = await fetchCode(GIST_ADD1TO100);
    editor2.setValue(c, -1);
    runPyodide(editor2, "kw_console2", "brython_div2");
  };

  document.getElementById("kw_run1").onclick = () =>
    runPyodide(editor1, "kw_console1", "brython_div1");
  document.getElementById("kw_run2").onclick = () =>
    runPyodide(editor2, "kw_console2", "brython_div2");
  document.getElementById("kw_clear_console1").onclick = () =>
    clearOutput("kw_console1", "brython_div1");
  document.getElementById("kw_clear_console2").onclick = () =>
    clearOutput("kw_console2", "brython_div2");
});

// 調整 output textarea 行數
document.getElementById("kw_output1").onclick = () => {
  const ta = document.getElementById("kw_console1");
  ta.rows = "15";
  ta.cols = "70";
  ta.scrollTop = 0;
};
document.getElementById("kw_output2").onclick = () => {
  const ta = document.getElementById("kw_console2");
  ta.rows = "15";
  ta.cols = "70";
  ta.scrollTop = 0;
};

async function fetchCode(url) {
  const r = await fetch(url);
  if (!r.ok) throw new Error(`載入失敗 ${r.status}`);
  return await r.text();
}

function clearOutput(consoleId, divId) {
  document.getElementById(consoleId).value = "";
  document.getElementById(divId).innerHTML = "";
}

async function runPyodide(editor, consoleId, divId) {
  document.getElementById(consoleId).value = "";
  document.getElementById(divId).innerHTML = "";

  await pyodide.runPythonAsync(`
import sys
class JsWriter:
  def write(self, s):
    from js import document
    ta = document.getElementById("${consoleId}")
    ta.value += s
    ta.scrollTop = ta.scrollHeight
sys.stdout = JsWriter()
sys.stderr = JsWriter()
`);

  try {
    await pyodide.runPythonAsync(editor.getValue());
  } catch (e) {
    document.getElementById(consoleId).value += "\\n錯誤：" + e.toString();
  }
}
</script>
</p>